[
  {
    "topicName": "C#",
    "questionAnswers": [
      {
        "question": "What are properties?",
        "answer": "A property is a class member and can be defined in interfaces or abstract classes. They provides a flexible mechanism to read, write, or compute the value of a private field. Properties are special methods called accessors. This enables data to be accessed easily and still helps promote the safety and flexibility of methods.               <ul><li><p>Properties enable a class to expose a public way of getting and setting values, while hiding implementation or verification code.</p></li><li><p>A get</a> property accessor is used to return the property value, and a set</a> property accessor is used to assign a new value.</a>.</p></li><li><p>The keyword is used to define the value being assigned by the <code>set</code> accessor.</p></li><li><p>Properties can be <em>read-write</em> (they have both a <code>get</code> and a <code>set</code> accessor), <em>read-only</em> (they have a <code>get</code> accessor but no <code>set</code> accessor), or <em>write-only</em> (they have a <code>set</code> accessor, but no <code>get</code> accessor) </p></li><li><p>Simple properties that require no custom accessor code can be implemented either as expression body definitions or as auto-implemented properties</a>.</p></li></ul>"
      },
      {
        "question": "What is the extension metod?",
        "answer": "<p>Extension methods are <code>static</code> methods. They enable you to 'add' methods to existing types without creating a new derived type or otherwise modifying the original type. Extension methods are static methods, but they're called as if they were instance methods on the extended type.</p>"
      },
      {
        "question": "Async vs Sync appraoch?",
        "answer": ""
      },
      {
        "question": "c# readonly vs const",
        "answer": "<h6><code>readonly</code></h6><ul><li>readonly is a runtime constant.</li>  <li>Assign values in declaration and in the contructor part.</li>  <li>It cannot be declared inside the method.</li>   <li>It can be used with static modifiers.</li></ul>   <ul> <h6><code>const</code></h6>  <li>Const is a compile time constant.</li>  <li>It can be declared inside the method.</li>    <li>It cannot be used with static modifiers.</li>  <li>Assign values in declaration part.</li></ul>"
      },
      {
        "question": "Boxing vs. Unboxing",
        "answer": "<ul><li>Boxing is implicit casting - Boxing is the process of converting a value type to the type object. CLR wraps value type inside object and stores it on the managed heap.</li>   <li>Unboxing - explicit casting. Unboxing extracts the value type from the object.</li><ul>"
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": ".NET",
    "questionAnswers": [
      {
        "question": "What is cancellation token?",
        "answer": "Cancellation token struct provides behaviour for cancellation of multiple threads, tasks or operations. Once Cancel() method is invoked it cancels the threads, tasks and operations to which is passed and throws <code>OperationCancelledException</code>."
      },
      {
        "question": "What is the purpose of IDisposable interface?",
        "answer": "<p> Implementing the Dispose method allows us to manually release unmanaged resources. Instance members that are IDisposable implementations, cascade Dispose calls. The invocation of the method frees memory that was allocated, remove an item that was added to a collection, or signal the release of a lock that was acquired.</p> <p>The .NET garbage collector does not allocate or release unmanaged memory.</p>"
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "SOLID",
    "questionAnswers": [
      {
        "question": "Single Responsibility principle",
        "answer": "Do one thing, but do it right. Methods, classes and other software entities and modules should be focues on single thing. In case the principle is not followed strictly and we have to change something there is a risk of side effects."
      },
      {
        "question": "Open-closed principle",
        "answer": "Software entities should be opened for extension, but closed for modification. In case we have working code in production we do not want to change it, since we can break it."
      },
      {
        "question": "Liskov substitution principle",
        "answer": "Instance of a child class must replace an instance of the parent class, without affecting the results that we would get from an instance of the base class itself."
      },
      {
        "question": "Interface segregation Principle",
        "answer": "Make fine grained, client specific interfaces. It is better to have many and small interfaces, than one big and shared interface. Having different small interfaces for each functionality will not force us to implement unneeded methods."
      },
      {
        "question": "Dependency Inversion Principle",
        "answer": "Depend on abstractions, not on implementations. High-level module should not depend on low-level modules. Both should depend on abstraction."
      }
    ]
  },
  {
    "topicName": "SQL",
    "questionAnswers": [
      {
        "question": "Inner join vs. Left join",
        "answer": "<p>Join</p> <ul><li>Combines the records from the table/s by comparing the values in the columns and returns the ones that matches the ON CLAUSE condition. Results with a new table.</li></ul>  <p>Inner join</p> <ul><li>The result contains those records from the table/s that both records meets the ON CLAUSE condition.</li></ul>  <p>Left join</p> <ul><li>The result contains those records from the right table that meets the ON CLAUSE condition and each record from the left table.</li></ul>"
      },
      {
        "question": "<span>What is Normalization?</span>",
        "answer": "<p>It is the process of eliminating redundant data and maintaining data dependencies.</p>"
      },
      {
        "question": "<span>What is a view?</span>",
        "answer": "<p>A <strong>view</strong> is simply a virtual table that is made up of elements of multiple physical or “real” tables. Views are most commonly used to join multiple tables together, or control access to any tables existing in background server processes.\t</p>"
      },
      {
        "question": "What are indexes?",
        "answer": "<p>Indexes are used to speed-up query process in SQL Server, resulting in high performance. They are similar to textbook indexes. In textbooks, if you need to go to a particular chapter, you go to the index, find the page number of the chapter and go directly to that page. Without indexes, the process of finding your desired chapter would have been very slow.</p>"
      },
      {
        "question": "MSSQL locking",
        "answer": ""
      },
      {
        "question": "Cluster vs. non-clustered index?",
        "answer": "<p>Clustered Index </p> <li> A clustered index defines the order in which data is physically stored in a table. Table data can be sorted in only way, therefore, there can be only one clustered index per table. In SQL Server, the primary key constraint automatically creates a clustered index on that particular column.</li> <p> Non-clustered Index </p> <li>A non-clustered index doesn’t sort the physical data inside the table. In fact, a non-clustered index is stored at one place and table data is stored in another place. This is similar to a textbook where the book content is located in one place and the index is located in another. This allows for more than one non-clustered index per table.</li>   <li>It is important to mention here that inside the table the data will be sorted by a clustered index. However, inside the non-clustered index data is stored in the specified order. The index contains column values on which the index is created and the address of the record that the column value belongs to.</li>   <li>When a query is issued against a column on which the index is created, the database will first go to the index and look for the address of the corresponding row in the table. It will then go to that row address and fetch other column values. It is due to this additional step that non-clustered indexes are slower than clustered indexes.</li>"
      },
      {
        "question": "What is a stored procedure?",
        "answer": "cached query plans"
      },
      {
        "question": "What are the different type of functions you can create?",
        "answer": "Table valued functions, scalar functions"
      },
      {
        "question": "What is Cursor?",
        "answer": ""
      },
      {
        "question": "Join Types",
        "answer": "<ul><li>Inner Join</li> <li>Left/Right Join</li>   <li>Full Outer Join</li>    <li>Cross Join</li>   <li>Self Join</li>  </ul>"
      },
      {
        "question": "Types of Transaction Isolation Levels",
        "answer": "<ul><li>Read Uncommitted</li>   <li>Read Committed</li>    <li>Snapshot</li>   <li>Serilizable</li>  <li>Repeatable read</li></ul>"
      },
      {
        "question": "What is table scan?",
        "answer": "Without indexes, a DBMS has to go through all the records in the table in order to retrieve the desired results. This process is called table-scanning and is extremely slow."
      },
      {
        "question": "READ UNCOMMITTED?",
        "answer": "<p>Specifies that statements can read rows that have been modified by other transactions but not yet committed. When this option is set, it is possible to read uncommitted modifications, which are called dirty reads.</p>"
      },
      {
        "question": "READ COMMITTED?",
        "answer": "Specifies that statements cannot read data that has been modified but not committed by other transactions.This prevents dirty reads. This option is the SQL Server default. The behavior of READ COMMITTED depends on the setting of the READ_COMMITTED_SNAPSHOT database option: If READ_COMMITTED_SNAPSHOT is set to OFF (the default), the Database Engine uses shared locks to prevent other transactions from modifying rows while the current transaction is running a read operation. The shared locks also block the statement from reading rows modified by other transactions until the other transaction is completed. If READ_COMMITTED_SNAPSHOT is set to ON, the Database Engine uses row versioning to present each statement with a transactionally consistent snapshot of the data as it existed at the start of the statement. Locks are not used to protect the data from updates by other transactions."
      },
      {
        "question": "SNAPSHOT?",
        "answer": "Specifies that data read by any statement in a transaction will be the transactionally consistent version of the data that existed at the start of the transaction. The transaction can only recognize data modifications that were committed before the start of the transaction. Data modifications made by other transactions after the start of the current transaction are not visible to statements executing in the current transaction. SNAPSHOT transactions do not request locks when reading data. SNAPSHOT transactions reading data do not block other transactions from writing data. Transactions writing data do not block SNAPSHOT transactions from reading data."
      },
      {
        "question": "REPEATABLE READ?",
        "answer": "Specifies that statements cannot read data that has been modified but not yet committed by other transactions and that no other transactions can modify data that has been read by the current transaction until the current transaction completes."
      },
      {
        "question": "SERIALIZABLE",
        "answer": "<li>Statements cannot read data that has been modified but not yet committed by other transactions.</li> <li>* No other transactions can modify data that has been read by the current transaction until the current transaction completes.</li> <li>* Other transactions cannot insert new rows with key values that would fall in the range of keys read by any statements in the current transaction until the current transaction completes.</li>"
      }
    ]
  },
  {
    "topicName": "LINQ",
    "questionAnswers": [
      {
        "question": "<span>What is LINQ? Why is it required?</span>",
        "answer": "<p><strong>Language Integrated Query</strong> or <strong>LINQ</strong> is the collection of standard query operators which provides query facilities into.NET framework language like C#, VB.NET. LINQ is required as it bridges the gap between the world of data and the world of objects.</p>"
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "OOP",
    "questionAnswers": [
      {
        "question": "Abstract class vs. Interface?",
        "answer": "<ul><li>Both cannot be instantiated, but abstract classes have constructors.</li><li>Interfaces cannot have implementations, but abstract classes can.</li><li>Interfaces can define only properties, methods, delegates and events, but abstract classes can define everything that classes can.</li><li>In C# we can implement multiple interfaces, but inherit from single abstract class.</li><li>Abstract classes could define any access modifiers, but interfaces does not specify modifiers, everything is public.</li></ul>"
      },
      {
        "question": "Inheritance",
        "answer": "Child class to receive behaviours, characteristics and data or other class members from a parent class."
      },
      {
        "question": "Abstraction",
        "answer": "Allows the performing of actions on a abstract level. Ignores aspects of information and focuses on the most important."
      },
      {
        "question": "Encapsulation",
        "answer": "Enables information hiding from some of the clients. Makes it impossible for the users of an object to change the state in an unexpected way."
      },
      {
        "question": "Polymorphism",
        "answer": "The ability to work with specific behaviours in class through an interface. This allows the functionality to be modified in a specific class."
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "Microservices",
    "questionAnswers": [
      {
        "question": "What are Microservices?",
        "answer": "<p>Microservice architecture - is an architectural style that structures an application as a collection of services that are</p><ul> <li>Highly maintainable and testable</li><li>Loosely coupled</li><li>Independently deployable</li><li>Organized around business capabilities</li><li>Owned by a small team</li></ul> The microservice architecture enables the rapid, frequent and reliable delivery of large, complex applications. It also enables an organization to evolve its technology stack.</div>"
      },
      {
        "question": "Pros and cons?",
        "answer": "<h6>Pros</h6><ul><li>Faster deployment</li><li>Easier to maintain, test, scale and change.</li><li>Higher availability</li><li>Easily change technology stack.</li><li>Easily separate business domains.</li><li>Good for small teams.</li><ul/><h6>Cons</h6><li>Requires deeper business understanding.</li><li>Learning curve is steep, so it requires more skilled developers/architects.</li>   <li>It is easy to get wrong the whole architecture - distributed monolith/coupled services.</li>    <li>Not good choice for prototyping.</li>"
      },
      {
        "question": "How do you split them?",
        "answer": "<h6>Split from a monolith</h6><ul><li>0 - Review the application level code to extract.</li><li>1 - Refactor the code to loosely coupled module.</li><li>2 - Split the database entities of the refactored module to new database.</li><li>3 - Define a standalone microservice</li><li>4 - Use the standalone microservice - rerouting the logic - http/grpc/amqp(message broker)</li></ul>"
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "Testing",
    "questionAnswers": [
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "Security",
    "questionAnswers": [
      {
        "question": "OAuth protocol",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "Code quality",
    "questionAnswers": [
      {
        "question": "Coupling vs. cohesion",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "DevOps",
    "questionAnswers": [
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "Design Patterns",
    "questionAnswers": [
      {
        "question": "Gang of four",
        "answer": ""
      },
      {
        "question": "Inversion of Control",
        "answer": "IOC and DI are design pattern aiming to reach loosely coupled application modules and make them easier for to test and maintain."
      },
      {
        "question": "MVC",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "git",
    "questionAnswers": [
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "REST",
    "questionAnswers": [
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "Angular",
    "questionAnswers": [
      {
        "question": "What is a component? Why would you use it?",
        "answer": "Components are the most basic building block of an UI in an Angular application. An Angular application is a tree of Angular components. Angular components are a subset of directives. Unlike directives, components always have a template and only one component can be instantiated per an element in a template. A component must belong to an NgModule in order for it to be usable by another component or application. To specify that a component is a member of an NgModule, you should list it in the declarations field of that NgModule."
      },
      {
        "question": "What is Routing Guard in Angular?",
        "answer": "Angular’s route guards are interfaces which can tell the router whether or not it should allow navigation to a requested route. They make this decision by looking for a true or false return value from a class which implements the given guard interface."
      },
      {
        "question": "What is a module, and what does it contain?",
        "answer": "An Angular module is set of Angular basic building blocks like component, directives, services etc. An app can have more than one module."
      },
      {
        "question": "What is interpolation?",
        "answer": "Interpolation is a special syntax that Angular converts into property binding. It’s a convenient alternative to property binding. It is represented by double curly braces({{}}). The text between the braces is often the name of a component property. Angular replaces that name with the string value of the corresponding component property."
      }
    ]
  },
  {
    "topicName": "JavaScript",
    "questionAnswers": [
      {
        "question": "What is Scope in JavaScript?",
        "answer": "In JavaScript, each function gets its own scope. Scope is basically a collection of variables as well as the rules for how those variables are accessed by name. <br/> Only code inside that function can access that function's scoped variables.   A variable name has to be unique within the same scope. A scope can be nested inside another scope. If one scope is nested inside another, code inside the innermost scope can access variables from either scope."
      },
      {
        "question": "<span>What does <code>use strict</code> do?</span>",
        "answer": "<p>The <code>use strict</code> literal is entered at the top of a JavaScript program or at the top of a function and it helps you write safer JavaScript code by throwing an error if a global variable is created by mistake. For example, the following program will throw an error:</p>"
      },
      {
        "question": "<span>Explain <code>Null</code> and <code>Undefined</code> in JavaScript</span>",
        "answer": "<p>JavaScript (and by extension TypeScript) has two bottom types: <code>null</code> and <code>undefined</code>. They are <em>intended</em> to mean different things:</p> <ul><li>Something hasn't been initialized : <code>undefined</code>.</li><li>Something is currently unavailable: <code>null</code>.</li></ul>"
      }
    ]
  },
  {
    "topicName": "Xamarin",
    "questionAnswers": [
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "TypeScript",
    "questionAnswers": [
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  }
]
