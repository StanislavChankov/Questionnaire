[
  {
    "topicName": "C#",
    "questionAnswers": [
      {
        "question": "What are properties?",
        "answer": "A property is a class member and can be defined in interfaces or abstract classes. They provides a flexible mechanism to read, write, or compute the value of a private field. Properties are special methods called accessors. This enables data to be accessed easily and still helps promote the safety and flexibility of methods.               <ul><li><p>Properties enable a class to expose a public way of getting and setting values, while hiding implementation or verification code.</p></li><li><p>A get</a> property accessor is used to return the property value, and a set</a> property accessor is used to assign a new value.</a>.</p></li><li><p>The keyword is used to define the value being assigned by the <code>set</code> accessor.</p></li><li><p>Properties can be <em>read-write</em> (they have both a <code>get</code> and a <code>set</code> accessor), <em>read-only</em> (they have a <code>get</code> accessor but no <code>set</code> accessor), or <em>write-only</em> (they have a <code>set</code> accessor, but no <code>get</code> accessor) </p></li><li><p>Simple properties that require no custom accessor code can be implemented either as expression body definitions or as auto-implemented properties</a>.</p></li></ul>"
      },
      {
        "question": "What is the extension metod?",
        "answer": "<p>Extension methods are <code>static</code> methods. They enable you to 'add' methods to existing types without creating a new derived type or otherwise modifying the original type. Extension methods are static methods, but they're called as if they were instance methods on the extended type.</p>"
      },
      {
        "question": "Async vs Sync appraoch?",
        "answer": ""
      },
      {
        "question": "c# readonly vs const",
        "answer": "<h6><code>readonly</code></h6><ul><li>readonly is a runtime constant.</li>  <li>Assign values in declaration and in the contructor part.</li>  <li>It cannot be declared inside the method.</li>   <li>It can be used with static modifiers.</li></ul>   <ul> <h6><code>const</code></h6>  <li>Const is a compile time constant.</li>  <li>It can be declared inside the method.</li>    <li>It cannot be used with static modifiers.</li>  <li>Assign values in declaration part.</li></ul>"
      },
      {
        "question": "Boxing vs. Unboxing",
        "answer": "<ul><li>Boxing is implicit casting - Boxing is the process of converting a value type to the type object. CLR wraps value type inside object and stores it on the managed heap.</li>   <li>Unboxing - explicit casting. Unboxing extracts the value type from the object.</li><ul>"
      },
      {
        "question": "value type vs. reference type",
        "answer": "<p><em>Value types</em> and <a>reference types</a> are the two main categories of C# types.</p> <p>A variable of a value type contains an instance of the type. This differs from a variable of a reference type, which contains a reference to an instance of the type. By default, on <a>assignment</a>, passing an argument to a method, and returning a method result, variable values are copied. In the case of value-type variables, the corresponding type instances are copied.</p>     <p>Variables of reference types store references to their data (objects), while variables of value types directly contain their data. With reference types, two variables can reference the same object; therefore, operations on one variable can affect the object referenced by the other variable. With value types, each variable has its own copy of the data, and it is not possible for operations on one variable to affect the other (except in the case of in, ref and out parameter variables.</p>"
      },
      {
        "question": "C# 9.0 features",
        "answer": "<ul> <li><a>Records</a></li><li><a>Init only setters</a></li> <li><a>Top-level statements</a></li><li><a>Pattern matching enhancements</a></li><li>Native sized integers</li><li>Function pointers</li><li>Suppress emitting localsinit flag</li><li>Target-typed new expressions</li><li>static anonymous functions</li><li>Target-typed conditional expressions</li><li>Covariant return types</li><li>Extension <code>GetEnumerator</code> support for <code>foreach</code> loops</li><li>Lambda discard parameters</li><li>Attributes on local functions</li><li>Module initializers</li><li>New features for partial methods</li></ul>"
      }
    ]
  },
  {
    "topicName": ".NET",
    "questionAnswers": [
      {
        "question": "What is cancellation token?",
        "answer": "Cancellation token struct provides behaviour for cancellation of multiple threads, tasks or operations. Once Cancel() method is invoked it cancels the threads, tasks and operations to which is passed and throws <code>OperationCancelledException</code>."
      },
      {
        "question": "What is the purpose of IDisposable interface?",
        "answer": "<p> Implementing the Dispose method allows us to manually release unmanaged resources. Instance members that are IDisposable implementations, cascade Dispose calls. The invocation of the method frees memory that was allocated, remove an item that was added to a collection, or signal the release of a lock that was acquired.</p> <p>The .NET garbage collector does not allocate or release unmanaged memory.</p>"
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "SOLID",
    "questionAnswers": [
      {
        "question": "What is SOLID",
        "answer": "<p>SOLID Principles is a coding standard that all developers should have a clear concept for developing software properly to avoid a bad design. It was promoted by Robert C Martin and is used across the object-oriented design spectrum. When applied properly it makes your code more extendable, logical, and easier to read.</p>"
      },
      {
        "question": "Single Responsibility principle",
        "answer": "Do one thing, but do it right. Methods, classes and other software entities and modules should be focues on single thing. In case the principle is not followed strictly and we have to change something there is a risk of side effects."
      },
      {
        "question": "Open-closed principle",
        "answer": "Software entities should be opened for extension, but closed for modification. In case we have working code in production we do not want to change it, since we can break it."
      },
      {
        "question": "Liskov substitution principle",
        "answer": "Instance of a child class must replace an instance of the parent class, without affecting the results that we would get from an instance of the base class itself."
      },
      {
        "question": "Interface segregation Principle",
        "answer": "Make fine grained, client specific interfaces. It is better to have many and small interfaces, than one big and shared interface. Having different small interfaces for each functionality will not force us to implement unneeded methods."
      },
      {
        "question": "Dependency Inversion Principle",
        "answer": "Depend on abstractions, not on implementations. High-level module should not depend on low-level modules. Both should depend on abstraction."
      }
    ]
  },
  {
    "topicName": "SQL",
    "questionAnswers": [
      {
        "question": "Inner join vs. Left join",
        "answer": "<p>Join</p> <ul><li>Combines the records from the table/s by comparing the values in the columns and returns the ones that matches the ON CLAUSE condition. Results with a new table.</li></ul>  <p>Inner join</p> <ul><li>The result contains those records from the table/s that both records meets the ON CLAUSE condition.</li></ul>  <p>Left join</p> <ul><li>The result contains those records from the right table that meets the ON CLAUSE condition and each record from the left table.</li></ul>"
      },
      {
        "question": "<span>What is Normalization?</span>",
        "answer": "<p>It is the process of eliminating redundant data and maintaining data dependencies.</p>"
      },
      {
        "question": "<span>What is a view?</span>",
        "answer": "<p>A <strong>view</strong> is simply a virtual table that is made up of elements of multiple physical or “real” tables. Views are most commonly used to join multiple tables together, or control access to any tables existing in background server processes.\t</p>"
      },
      {
        "question": "What are indexes?",
        "answer": "<p>Indexes are used to speed-up query process in SQL Server, resulting in high performance. They are similar to textbook indexes. In textbooks, if you need to go to a particular chapter, you go to the index, find the page number of the chapter and go directly to that page. Without indexes, the process of finding your desired chapter would have been very slow.</p>"
      },
      {
        "question": "MSSQL locking",
        "answer": ""
      },
      {
        "question": "Cluster vs. non-clustered index?",
        "answer": "<p>Clustered Index </p> <li> A clustered index defines the order in which data is physically stored in a table. Table data can be sorted in only way, therefore, there can be only one clustered index per table. In SQL Server, the primary key constraint automatically creates a clustered index on that particular column.</li> <p> Non-clustered Index </p> <li>A non-clustered index doesn’t sort the physical data inside the table. In fact, a non-clustered index is stored at one place and table data is stored in another place. This is similar to a textbook where the book content is located in one place and the index is located in another. This allows for more than one non-clustered index per table.</li>   <li>It is important to mention here that inside the table the data will be sorted by a clustered index. However, inside the non-clustered index data is stored in the specified order. The index contains column values on which the index is created and the address of the record that the column value belongs to.</li>   <li>When a query is issued against a column on which the index is created, the database will first go to the index and look for the address of the corresponding row in the table. It will then go to that row address and fetch other column values. It is due to this additional step that non-clustered indexes are slower than clustered indexes.</li>"
      },
      {
        "question": "What is a stored procedure?",
        "answer": "cached query plans"
      },
      {
        "question": "What are the different type of functions you can create?",
        "answer": "Table valued functions, scalar functions"
      },
      {
        "question": "What is Cursor?",
        "answer": "<p>Microsoft SQL Server statements produce a complete result set, but there are times when the results are best processed one row at a time. Opening a cursor on a result set allows processing the result set one row at a time. You can assign a cursor to a variable or parameter with a <strong>cursor</strong> data type.</p>"
      },
      {
        "question": "Join Types",
        "answer": "<ul><li>Inner Join</li> <li>Left/Right Join</li>   <li>Full Outer Join</li>    <li>Cross Join</li>   <li>Self Join</li>  </ul>"
      },
      {
        "question": "Types of Transaction Isolation Levels",
        "answer": "<ul><li>Read Uncommitted</li>   <li>Read Committed</li>    <li>Snapshot</li>   <li>Serilizable</li>  <li>Repeatable read</li></ul>"
      },
      {
        "question": "What is table scan?",
        "answer": "Without indexes, a DBMS has to go through all the records in the table in order to retrieve the desired results. This process is called table-scanning and is extremely slow."
      },
      {
        "question": "READ UNCOMMITTED?",
        "answer": "<p>Specifies that statements can read rows that have been modified by other transactions but not yet committed. When this option is set, it is possible to read uncommitted modifications, which are called dirty reads.</p>"
      },
      {
        "question": "READ COMMITTED?",
        "answer": "Specifies that statements cannot read data that has been modified but not committed by other transactions.This prevents dirty reads. This option is the SQL Server default. The behavior of READ COMMITTED depends on the setting of the READ_COMMITTED_SNAPSHOT database option: If READ_COMMITTED_SNAPSHOT is set to OFF (the default), the Database Engine uses shared locks to prevent other transactions from modifying rows while the current transaction is running a read operation. The shared locks also block the statement from reading rows modified by other transactions until the other transaction is completed. If READ_COMMITTED_SNAPSHOT is set to ON, the Database Engine uses row versioning to present each statement with a transactionally consistent snapshot of the data as it existed at the start of the statement. Locks are not used to protect the data from updates by other transactions."
      },
      {
        "question": "SNAPSHOT?",
        "answer": "Specifies that data read by any statement in a transaction will be the transactionally consistent version of the data that existed at the start of the transaction. The transaction can only recognize data modifications that were committed before the start of the transaction. Data modifications made by other transactions after the start of the current transaction are not visible to statements executing in the current transaction. SNAPSHOT transactions do not request locks when reading data. SNAPSHOT transactions reading data do not block other transactions from writing data. Transactions writing data do not block SNAPSHOT transactions from reading data."
      },
      {
        "question": "REPEATABLE READ?",
        "answer": "Specifies that statements cannot read data that has been modified but not yet committed by other transactions and that no other transactions can modify data that has been read by the current transaction until the current transaction completes."
      },
      {
        "question": "SERIALIZABLE",
        "answer": "<li>Statements cannot read data that has been modified but not yet committed by other transactions.</li> <li>* No other transactions can modify data that has been read by the current transaction until the current transaction completes.</li> <li>* Other transactions cannot insert new rows with key values that would fall in the range of keys read by any statements in the current transaction until the current transaction completes.</li>"
      }
    ]
  },
  {
    "topicName": "Computer Science",
    "questionAnswers": [
      {
        "question": "Big O notation",
        "answer": "<ol><li>O(1) means in constant time - independent of the number of items.</li><li>O(N) means in proportion to thenumber of items.</li><li>O(log N) means a time proportional tolog(N)</li></ol>"
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "LINQ",
    "questionAnswers": [
      {
        "question": "<span>What is LINQ? Why is it required?</span>",
        "answer": "<p><strong>Language Integrated Query</strong> or <strong>LINQ</strong> is the collection of standard query operators which provides query facilities into.NET framework language like C#, VB.NET. LINQ is required as it bridges the gap between the world of data and the world of objects.</p>"
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "OOP",
    "questionAnswers": [
      {
        "question": "Abstract class vs. Interface?",
        "answer": "<ul><li>Both cannot be instantiated, but abstract classes have constructors.</li><li>Interfaces cannot have implementations, but abstract classes can.</li><li>Interfaces can define only properties, methods, delegates and events, but abstract classes can define everything that classes can.</li><li>In C# we can implement multiple interfaces, but inherit from single abstract class.</li><li>Abstract classes could define any access modifiers, but interfaces does not specify modifiers, everything is public.</li></ul>"
      },
      {
        "question": "Inheritance",
        "answer": "Child class to receive behaviours, characteristics and data or other class members from a parent class."
      },
      {
        "question": "Abstraction",
        "answer": "Allows the performing of actions on a abstract level. Ignores aspects of information and focuses on the most important."
      },
      {
        "question": "Encapsulation",
        "answer": "Enables information hiding from some of the clients. Makes it impossible for the users of an object to change the state in an unexpected way."
      },
      {
        "question": "Polymorphism",
        "answer": "The ability to work with specific behaviours in class through an interface. This allows the functionality to be modified in a specific class."
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "Microservices",
    "questionAnswers": [
      {
        "question": "What are Microservices?",
        "answer": "<p>Microservice architecture - is an architectural style that structures an application as a collection of services that are</p><ul> <li>Highly maintainable and testable</li><li>Loosely coupled</li><li>Independently deployable</li><li>Organized around business capabilities</li><li>Owned by a small team</li></ul> The microservice architecture enables the rapid, frequent and reliable delivery of large, complex applications. It also enables an organization to evolve its technology stack.</div>"
      },
      {
        "question": "Pros and cons?",
        "answer": "<h6>Pros</h6><ul><li>Faster deployment</li><li>Easier to maintain, test, scale and change.</li><li>Higher availability</li><li>Easily change technology stack.</li><li>Easily separate business domains.</li><li>Good for small teams.</li><ul/><h6>Cons</h6><li>Requires deeper business understanding.</li><li>Learning curve is steep, so it requires more skilled developers/architects.</li>   <li>It is easy to get wrong the whole architecture - distributed monolith/coupled services.</li>    <li>Not good choice for prototyping.</li>"
      },
      {
        "question": "How do you split them?",
        "answer": "<h6>Split from a monolith</h6><ul><li>0 - Review the application level code to extract.</li><li>1 - Refactor the code to loosely coupled module.</li><li>2 - Split the database entities of the refactored module to new database.</li><li>3 - Define a standalone microservice</li><li>4 - Use the standalone microservice - rerouting the logic - http/grpc/amqp(message broker)</li></ul>"
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "Testing",
    "questionAnswers": [
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "Security",
    "questionAnswers": [
      {
        "question": "OAuth",
        "answer": "<p>it’s an open standard for authorization, but not for authentication. OAuth authorizes devices, APIs, servers, and applications with access tokens rather than credentials.</p><p>There are two versions of OAuth: OAuth 1.0a and OAuth 2.0. These specifications are completely different from one another, and cannot be used together: there is no backwards compatibility between them.</p>"
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "Code quality",
    "questionAnswers": [
      {
        "question": "Coupling vs. cohesion",
        "answer": "<b>Cohesion:</b><br>Cohesion is the indication of the relationship within module. It is concept of intra-module. Cohesion has many types but usually highly cohesion is good for software.</p> <p><b>Coupling:</b><br> Coupling is also the indication of  the relationships between modules. It is concept of Inter-module. Coupling has also many types but usually low coupling is good for software.</p>"
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "DevOps",
    "questionAnswers": [
      {
        "question": "Continuous integration",
        "answer": "<p>The developer's changes are validated by creating a build and running automated tests against the build.&nbsp;By doing so, you avoid&nbsp;integration challenges that can happen when waiting for release day to merge&nbsp;changes into the release branch.</p> <p>Continuous integration puts a great emphasis on testing automation to check that the application is not broken whenever new commits are&nbsp;integrated into the main branch.</p>"
      },
      {
        "question": "Continuous delivery",
        "answer": "<p><a>Continuous delivery</a>&nbsp;is an extension of continuous integration since it automatically deploys all code changes to a testing and/or production environment after the build stage.&nbsp;</p> <p>This means that on top of automated testing, you&nbsp;have an <b>automated release process</b> and you can deploy your application any time by clicking&nbsp;a button.</p> <p>In theory, with continuous delivery, you can decide to release daily, weekly, fortnightly, or whatever suits your business requirements.</p>"
      },
      {
        "question": "Continuous deployment",
        "answer": "<p><a>Continuous deployment</a> goes one step further than continuous delivery. With this practice, every change that passes all stages of your production pipeline&nbsp;is released to your customers. There's no human intervention, and only a failed test will prevent a new change to be deployed to production.</p><p>Continuous deployment is an excellent way to accelerate the feedback loop with your customers and take pressure off the team as there isn't a&nbsp;<em>Release Day</em>&nbsp;anymore. Developers can focus on building software, and they see their work go live minutes after they've finished working on it.</p>"
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "Design Patterns",
    "questionAnswers": [
      {
        "question": "Gang of four",
        "answer": "<p><a href=\"http://www.blackwasp.co.uk/gofpatterns.aspx\">Gang of four!</a></p>   <p><a href=\"https://refactoring.guru/design-patterns/catalog\">Refactoring guru!</a></p>    <p><a href=\"https://sourcemaking.com/design_patterns\">Source Making</p>"
      },
      {
        "question": "Inversion of Control",
        "answer": "IOC and DI are design pattern aiming to reach loosely coupled application modules and make them easier for to test and maintain."
      },
      {
        "question": "MVC",
        "answer": "<dl><dt>Model</dt><dd>The central component of the pattern. It is the application's dynamic data structure, independent of the user interface</a></sup> It directly manages the data, logic and rules of the application.</dd><dt>View</dt><dd>Any representation of information such as a chart, diagram or table. Multiple views of the same information are possible, such as a bar chart for management and a tabular view for accountants.</dd><dt>Controller</dt><dd>Accepts input and converts it to commands for the model or view</a></sup></dd></dl><p>In addition to dividing the application into these components, the model–view–controller design defines the interactions between them.</a></sup></p><ul><li>The model is responsible for managing the data of the application. It receives user input from the controller.</li><li>The view means presentation of the model in a particular format.</li><li>The controller responds to the user input and performs interactions on the data model objects. The controller receives the input, optionally validates it and then passes the input to the model.</li></ul>"
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "git",
    "questionAnswers": [
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "REST",
    "questionAnswers": [
      {
        "question": "Statelessness",
        "answer": "<p>In a client–server interaction, state is made up of intrinsic state and extrinsic state. <p><b>Intrinsic state</b>, called resource state, is stored on the server and consists of information that is independent of the server’s context, thereby making it <b>sharable</b> to all clients of the server.</p> <p><b>Extrinsic state</b>, called application state, is stored on each client and consists of information that is dependent on the server’s context and therefore <b>cannot be shared</b>. Clients are responsible for passing application state to the server when it needs it. The constraint of storing application state on the client rather than on the server makes the communication stateless.</p>"
      },
      {
        "question": "Cacheability",
        "answer": "<p>As on the World Wide Web, clients and intermediaries can cache responses. Responses must, implicitly or explicitly, define themselves as either cacheable or non-cacheable to prevent clients from providing stale or inappropriate data in response to further requests. Well-managed caching partially or completely eliminates some client–server interactions, further improving scalability and performance.</p>"
      },
      {
        "question": "Layered system",
        "answer": "A client cannot ordinarily tell whether it is connected directly to the end server or to an intermediary along the way. If a proxy or load balancer is placed between the client and server, it won't affect their communications, and there won't be a need to update the client or server code. Intermediary servers can improve system scalability by enabling load balancing and by providing shared caches. Also, security can be added as a layer on top of the web services, separating business logic from security logic. Adding security as a separate layer enforces security policies. Finally, intermediary servers can call multiple other servers to generate a response to the client."
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "Angular",
    "questionAnswers": [
      {
        "question": "What is a component? Why would you use it?",
        "answer": "Components are the most basic building block of an UI in an Angular application. An Angular application is a tree of Angular components. Angular components are a subset of directives. Unlike directives, components always have a template and only one component can be instantiated per an element in a template. A component must belong to an NgModule in order for it to be usable by another component or application. To specify that a component is a member of an NgModule, you should list it in the declarations field of that NgModule."
      },
      {
        "question": "What is Routing Guard in Angular?",
        "answer": "Angular’s route guards are interfaces which can tell the router whether or not it should allow navigation to a requested route. They make this decision by looking for a true or false return value from a class which implements the given guard interface."
      },
      {
        "question": "What is a module, and what does it contain?",
        "answer": "An Angular module is set of Angular basic building blocks like component, directives, services etc. An app can have more than one module."
      },
      {
        "question": "What is interpolation?",
        "answer": "Interpolation is a special syntax that Angular converts into property binding. It’s a convenient alternative to property binding. It is represented by double curly braces({{}}). The text between the braces is often the name of a component property. Angular replaces that name with the string value of the corresponding component property."
      }
    ]
  },
  {
    "topicName": "JavaScript",
    "questionAnswers": [
      {
        "question": "What is Scope in JavaScript?",
        "answer": "In JavaScript, each function gets its own scope. Scope is basically a collection of variables as well as the rules for how those variables are accessed by name. <br/> Only code inside that function can access that function's scoped variables.   A variable name has to be unique within the same scope. A scope can be nested inside another scope. If one scope is nested inside another, code inside the innermost scope can access variables from either scope."
      },
      {
        "question": "<span>What does <code>use strict</code> do?</span>",
        "answer": "<p>The <code>use strict</code> literal is entered at the top of a JavaScript program or at the top of a function and it helps you write safer JavaScript code by throwing an error if a global variable is created by mistake. For example, the following program will throw an error:</p>"
      },
      {
        "question": "<span>Explain <code>Null</code> and <code>Undefined</code> in JavaScript</span>",
        "answer": "<p>JavaScript (and by extension TypeScript) has two bottom types: <code>null</code> and <code>undefined</code>. They are <em>intended</em> to mean different things:</p> <ul><li>Something hasn't been initialized : <code>undefined</code>.</li><li>Something is currently unavailable: <code>null</code>.</li></ul>"
      }
    ]
  },
  {
    "topicName": "Xamarin",
    "questionAnswers": [
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  },
  {
    "topicName": "TypeScript",
    "questionAnswers": [
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      },
      {
        "question": "",
        "answer": ""
      }
    ]
  }
]
